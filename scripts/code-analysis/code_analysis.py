import argparse
import re
import sys
import glob
import os
import math
import binascii
import random
import subprocess

from collections import defaultdict

GENGRAPH_PATH = "/home/adamiaonr/workbench/codeviz/bin/gengraph"

def add_quote(line):
    nodes = line.split(" -> ")
    line = ('"%s" -> "%s";\n' % (nodes[0], nodes[1].rstrip(";\n")))
    return line

def to_pdf(dotfile, out_filename):

    args = ("dot", 
        "-Tpdf", dotfile, 
        "-o", ("%s.pdf" % (out_filename)))

    with open(os.devnull, 'w') as devnull:
        subprocess.check_call(args, stdout=devnull)

def print_callers(filename, function_name, depth = 3):

    # we save function names in a dict of queues, indexed by levels: level 0 
    # is function_name
    function_queue = defaultdict(list)
    function_queue[0].append(("-> %s" % (function_name)))

    # while capturing parent functions, we build a callgraph in a .dot file
    dotfilename = ("%s-%d.dot" % (function_name, depth))
    dotfile = open(dotfilename, 'w+')
    dotfile.write("""
digraph {
overlap = false;
pack = false;
splines = curved;
nodesep = 0.35;
graph [ dpi = 300 ]; 
node [ fontsize = 8 ];
edge [ fontsize = 6 ];
""")

    # go 'up', for a max. of depth levels
    for d in xrange(depth):
        # collect the parents of the next function in the current call level
        for func in function_queue[d]:
            with open(filename, 'r') as fin: 
                for line in fin:
                    if func in line:
                        # we save the next function w/ the format '-> <func-name>'
                        next_function = ("-> %s" % (line.split(" -> ")[0]))
                        if next_function:
                            # add parent functions to the upper-level queue
                            function_queue[d + 1].append(next_function)
                            # write line in the ouyput .dot file
                            dotfile.write(add_quote(line))

    # add final '}' and close the callgraph .dot file
    dotfile.write("""
}
""")
    dotfile.close()
    # convert .dot file to .pdf
    to_pdf(dotfilename, ("%s-%d" % (function_name, depth)))

if __name__ == "__main__":

    # use an ArgumentParser for a nice CLI
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "--graph-file", 
         help = """.graph file generated by codeviz genfull""")

    parser.add_argument(
        "--max-depth", 
         help = """max. depth of graph""")

    parser.add_argument(
        "--print-callers", 
         help = """print callgraph of callers of function. e.g. --print-callers <function-name>.""")

    args = parser.parse_args()

    if not args.graph_file:
        sys.stderr.write("""%s: [ERROR] please supply .graph file\n""" % sys.argv[0]) 
        parser.print_help()
        sys.exit(1)

    if not args.max_depth:
        args.max_depth = 3
        sys.stderr.write("""%s: [INFO] no max. depth specified. assuming max. depth = %d\n""" % (sys.argv[0], args.max_depth))

    if args.print_callers:
        print_callers(args.graph_file, args.print_callers, int(args.max_depth))
    else:
        sys.stderr.write("""%s: [ERROR] please supply a valid case\n""" % sys.argv[0]) 
        parser.print_help()
        sys.exit(1)